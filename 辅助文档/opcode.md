Zend/
# 458		zend_vm_opcodes.c
# 291		zend_vm_opcodes.h
<- 表示被调用关系

定义opcode操作码,203个
<- zend_vm_opcodes.c : zend_get_opcode_flags()
	+ zend_get_opcode_name() 一样
<- zend_dump.c : zend_dump_op()
<- zend_dump.c : zend_dump_op_line()
<- zend_dump.c : zend_dump_op_array()
	+ zend_dump_op_array_name() 这俩个函数是简单的输出
	不过是输出到 stderr 里
	
这两个在 Zend\Optimizer 里调用


zend_vm_opcodes.c : zend_get_opcode_name()
<- \Zend\Optimizer\zend_inference.c : emit_type_narrowing_warning()

zend_vm_opcodes.c : zend_get_opcode_id
<- ext\zend_test\observer.c
	这个更不靠谱

本来以为可以跟踪到生成opcode的逻辑，
所以opcode的定义主要是用来报错的？

# Zend\zend_vm_def.h
/* If you change this file, please regenerate the zend_vm_execute.h and
 * zend_vm_opcodes.h files by running:
 * php zend_vm_gen.php
 */
 
原来这个文件是用Php生成的

readme 里有关zend_vm 的操作码的介绍

The executors code is generated by the PHP script `zend_vm_gen.php`. It uses
`zend_vm_def.h` and `zend_vm_execute.skl` as input and produces
`zend_vm_opcodes.h` and `zend_vm_execute.h`. The first file is a list of opcode
definitions. It is included from `zend_compile.h`. The second one is an executor
code itself. It is included from `zend_execute.c`.

`zend_vm_gen.php` can produce different kind of executors. You can select a
different opcode threading model using `--with-vm-kind=CALL|SWITCH|GOTO|HYBRID`.
You can disable opcode specialization using `--without-specializer`.
At last you can debug the executor using the original `zend_vm_def.h` or the
generated `zend_vm_execute.h` file. Debugging with the original file requires
the `--with-lines` option. By default, Zend Engine uses the following
command to generate the executor: